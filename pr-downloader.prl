#!/usr/bin/env perl

use strict;
use warnings;
use autodie;
use threads ('stack_size' => 64*4096,
             'exit' => 'threads_only',
             'stringify');

use File::Fetch;
use File::Basename qw( fileparse );
use File::Path qw( make_path );
use File::Temp qw/ tempfile tempdir /;
use File::Spec;
use Thread::Semaphore;
use IO::Handle;
sub mkdirfor {
  my ($path) = @_;
  my ($filename, $directories) = fileparse $path;
  if (!-d $directories) {
      make_path $directories or die "Failed to create path: $directories";
  }
}

sub sha256sum {
  my ($file) = @_;
  my $hash = `sha256sum $file` or die "Failed to hash $file";
  my @fields = split(/ /, $hash);
  return $fields[0];
}

sub curl {
  my ($url) = @_;
  (undef, my $outfile) = tempfile(OPEN => 0);
  my @args = ("curl", "-Lsfk", $url, "-o", $outfile, "--retry", "12", "--retry-all-errors");
  system(@args) == 0 or die "Failed to curl $url: $?\n";
  my $hash = sha256sum($outfile);
  return $outfile, $hash;
}

sub gunzip {
  my ($path) = @_;
  (undef, my $filename) = tempfile(OPEN => 0);
  system("gzip -dc $path > $filename") == 0 or die "Failed to gunzip $path: $?\n";
  return $filename;
}

sub remove_scheme {
  my ($url) = @_;
  (my $scheme, $url) = $url =~ m{^(http|https)://(.*)/?};
  return $url;
}

my %seen_nix = ();
sub add_nix_file {
  my ($out_fh, $download_url, $target_file) = @_;
  if ($seen_nix{$target_file}) {
    return;
  }

  $seen_nix{$target_file} = 1;
  print $out_fh "$download_url\n  out=$target_file\n";
}

################################
## DOWNLOAD repos.gz
################################

sub repo_for {
  my ($out_fh, $server, $package) = @_;
  my $uri = remove_scheme $server;

  my ($path, $hash) = curl("$server/repos.gz");
  my $unzipped = gunzip $path;

  open my $fh, '<', $unzipped or die;
  while (my $line = <$fh>) {
    my @fields = split(/,/, $line);
    if ($fields[0] eq $package) {
      close $fh;
      return $fields[1];
    }
  }
  close $fh;
  die "$package not found in $path\n";

  add_nix_file $out_fh, "$server/repos.gz", "rapid/$uri/repos.gz";
}

################################
## DOWNLOAD versions.gz
################################
sub download_versions {
  my ($out_fh, $server, $package) = @_;
  my $uri = remove_scheme $server;

  my ($path, $hash) = curl("$server/versions.gz");
  my $unzipped = gunzip $path;

  add_nix_file $out_fh, "$server/versions.gz", "rapid/$uri/versions.gz";

  return $unzipped;
}

sub latest_version_for {
  my ($unzipped, $package, $tag) = @_;

  my $full_package = "$package:$tag";
  my $found_package = "";
  my $found_md5 = "";

  open my $fh, '<', $unzipped or die;
  while (my $line = <$fh>) {
    my @fields = split(/,/, $line);
    if ($fields[0] eq $full_package and $fields[3] ge $found_package) {
      $found_md5 = $fields[1];
      $found_package = $fields[3];
    }
  }
  close $fh;

  if ($found_package eq "") {
    die "No versions found for $package\n";
  }

  return $found_md5;
}

################################
## DOWNLOAD sdp
################################

sub download_sdp {
  my ($out_fh, $server, $md5) = @_;

  my ($path, $hash) = curl("$server/packages/$md5.sdp");
  my $unzipped = gunzip $path;

  add_nix_file $out_fh, "$server/packages/$md5.sdp", "packages/$md5.sdp";

  return $unzipped;
}

sub download_sdp_files {
  my ($out_fh, $repo, $filename) = @_;
  (undef, my $aria_fn) = tempfile(OPEN => 0);

  open my $fh, '<:raw', $filename or die;

  my $length = '';
  my $name = '';
  my $md5 = '';
  my $crc32 = '';
  my $size = '';
  my %seen = ();

  for (my $count = 0; $count < 10;) {
    my $success = read $fh, $length, 1;
    die $! if not defined $success;
    last if not $success;

    my $name_length = unpack('C', $length);
    $success = read $fh, $name, $name_length;
    die $! if not defined $success;
    last if not $success;

    $success = read $fh, $md5, 16;
    die $! if not defined $success;
    last if not $success;

    $success = read $fh, $crc32, 4;
    die $! if not defined $success;
    last if not $success;

    $success = read $fh, $size, 4;
    die $! if not defined $success;
    last if not $success;

    my $md5_hex = unpack('H*', $md5);
    my $crc32_hex = unpack('H*', $crc32);
    my $size_hex = unpack('H*', $size);

    unless ($seen{$md5_hex}) {
      $seen{$md5_hex} = 1;
      print "$md5_hex $name added.\n";
      my $first_two = substr $md5_hex, 0, 2;
      my $remainder = substr $md5_hex, 2;
      my $path = "pool/$first_two/$remainder.gz";

      my $download_url = "$repo/$path";
      add_nix_file $out_fh, $download_url, "$path";
    } else {
      print "$md5_hex $name is duplicated.\n";
    }
  }

  close $fh;
}

################################
## ENTRY
################################

my ($server) = @ARGV;

mkdirfor "sources/files.nix";
open my $out_fh, '>', "sources/files.list" or die;

foreach my $argnum (1 .. $#ARGV) {
  my @fields = split(/:/, $ARGV[$argnum]);
  my $package = $fields[0];
  my $tag = $fields[1];

  my $repo = repo_for $out_fh, $server, $package;
  my $versions_file = download_versions $out_fh, $repo, $package;
  my $version = latest_version_for $versions_file, $package, $tag;
  my $files = download_sdp $out_fh, $repo, $version;
  download_sdp_files $out_fh, $repo, $files;
}

close $out_fh;
